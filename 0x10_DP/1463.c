//1463 1로 만들기       //DP이용, bfs도 가능
#include <stdio.h>
int x;
int d[1000005];
int min(int a, int b){  //최소값 찾는 함수
    return a > b ? b : a;
}
int main(){
    scanf("%d", &x);
    d[1] = 0;
    for(int i = 2; i <= x; i++){
        d[i] = d[i-1] + 1;  //우선 d[i]에 1을 뺀 것에 대해서 수행해준 값을 넣어주고
        if(i % 3 == 0)  //3으로 나누어 떨어지는 수라면
            d[i] = min(d[i/3] + 1, d[i]);   //3으로 나눈 값을 인덱스로 가지는 친구에 대해서 수행해준 값과, 자기자신과 비교하여 최소값 넣어줌
        if(i % 2 == 0)  //2로 나누어 떨어지는 수라면
            d[i] = min(d[i/2] + 1, d[i]);   //2로 나눈 값을 인덱스로 가지는 친구에 대해서 수행해준 값과, 자기자신과 비교하여 최소값 넣어줌. (3으로 나누었을때와 -1해주었을때와 2로 해주었을때까지 다 봐줄 수 있는거임)
    }
    printf("%d", d[x]); //정답 출력

    return 0;
}
// 다이나믹 프로그래밍
// 1. 테이블 정의하기
// 2. 점화식 찾기
// 3. 초기값 정의하기
// 다이나믹 프로그래밍은 테이블을 잘 정의하고 점화식 찾아주고
// 초기값 잘 정의한 다음에 반복문 수행하면서 테이블들 채워주면 됨

// 이 문제의 경우
//      1. 테이블을 이렇게 정의함
// D[i]는 i 값을 1로 만드는 최소 경우의 수로 잡았음
// ex)D[3] 은 3을 1로 만드는 최소 경우의 수
//      2. 점화식은 이렇게 정의함
// 이전 인덱스에 대한 배열 값들을 알고 있는 경우라면
// D[k] 는 D[k-1] + 1, D[k/2] + 1, D[k/3] + 1 의 최소값임
// 물론 2로 나눌때와 3으로 나눌때는 나누어 떨어질때만 해줘야함
//      3. 초기값 정의하기
// D[1] = 0이라고 해줬음. 왜냐하면 1은 0번 수행해도 1이니까.